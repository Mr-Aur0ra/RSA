题目给出p-q，n，e和c。

常规的RSA解密步骤：

```asciiarmor
n = p*q
phi = (p-1)*(q-1)
d = gmpy2.invert(e,phi)
m = pow(c,d,n)
```

因为n不可分解，所以，我们无法直接得到p和q的值，也就无法得到phi的值。

通过对phi的如下分解可知，如果已知n和p+q便可求得phi的值。

```asciiarmor
phi = (p-1)*(q-1)
		= p*q - (p+q) + 1
		= n - (p+q) + 1
```

因为，给了p-q的值，所以，我们需要设法将p+q表示为p-q，进而求得phi的值。

推导过程如下：

p-q的平方可以如下分解：
$$
(p-q)^2 = p^2 + q^2 -2pq
$$
因此：
$$
p^2 + q^2 = (p-q)^2 +2pq
$$
p+q的平方可以如下分解：
$$
\begin{aligned}
(p+q)^2 &= p^2 + q^2 + 2pq \\ 
&= (p-q)^2 + 2pq + 2pq \\
&= (p-q)^2 + 4pq
\end{aligned}
$$
故p+q可表示为：
$$
\begin{aligned}
p+q &= \sqrt{(p-q)^2 + 4pq} \\
&= \sqrt{(p-q)^2 + 4n} 
\end{aligned}
$$
这样，我们就可以求出p+q的值，进而可以求出phi的值。最后就可以求出明文m的值了。

解题脚本如下：

```python
#!/usr/bin/python
#coding:utf-8
#变量p_add_q：p + q
#变量p_sub_q：p - q

import gmpy2
from Crypto.Util.number import long_to_bytes

n = 27552304606229034903366058815849954030287648695063385362955432137790872571412035824128918674719247737295565001575991597519270789776408208970323808016733976338433371328100880898942106515627607388226912870981180215883273805491209461671730377099185278711453949265641966582563910708529619185885928310168288810488784242368160743359666583499117949407921812317700250240067929572558785431071173411100434109661677786734923283679392823901052633992456780285091988542875991410528415886437666510014123352497264017734716859350294159440761760921548702546470902740121962033241003215821780125194400741190925169397917247376657863011603
e = 65537 
c = 8643831704675414121804983915084443744489969712473300784256427784417167322852556975560503484179280700293119974607254037642425650493676448134024809335297135239994950178868535219541095694358323044214971760829173918774094415933808417722001811285178546917655837402000771685507972240389565704149610032767242977174132826100177368764169367458684152505611469248099487912367364804360878611296860803835816266114046682291529593099394952245852157119233687981777202751472502060481232341206366584532964027749320641690448228420342308891797513656897566100268729012788419021059054907653832828437666012596894150751431936476816983845357
p_sub_q = 3216514606297172806828066063738105740383963382396892688569683235383985567043193404185955880509592930874764682428425994713750665248099953457550673860782324431970917492727256948066013701406000049963109681898567026552657377599263519201715733179565306750754520746601394738797021362510415215113118083969304423858

p_add_q = gmpy2.iroot(p_sub_q**2 + 4*n, 2)  
#iroot()返回值为一个(x,y)元组。其中x为结果值，y为一个bool型变量，如果x为整数，y=True,否则y=False。


phi = n - p_add_q[0] + 1

d = gmpy2.invert(e,phi)

m = pow(c,d,n)

print(long_to_bytes(m))
```

运行结果：

```asciiarmor
flag{9c0532a253809f180747b6da334b438f}
```





















